<!doctype html>
{% extends "base.html" %}
{% block content %}
<html lang="en">
<head>
</head>
<body>
<div class="container">
    <div class="row">
        <h2>Design Principal</h2>
        <h4>Design Principals are the rules which help develop a understandable, reusable code</h4>
    </div>
    <div class="row">
        <div class="row mb-1">
            <div class="col-9">
                <div class="card">
                    <div class="card-header h5">SOLID Principal</div>
                    <h5> SOLID is a set of object oriented design principles aimed at making code more maintainable and
                        flexible</h5>
                    <div class="card-body"><h5>S - Single-responsiblity Principle</h5>
                        <p class="h6"> "A class should have one and only one reason to change, meaning that a class
                            should
                            have
                            only one job." In the below example on Calculator we can see that each class carries only
                            one
                            responsibility example Addition class des only Addition</p>
                        <div class="card">
                            <div class="card-body bg-dark text-white">
                                <h6>class Addition:<br>
                                    """Addition function"""<br>
                                    @classmethod<br>
                                    def add(cls, value1, value2,):<br>
                                    """Add numbers"""<br>
                                    result = value1+value2<br>
                                    return result</h6>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col">
                <div class="row">
                    <div class="card">
                        <div class="card-body">
                            <h6 class="card-title">Reference links SOLID:<br>
                                <a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#single-responsibility-principle"
                                   class="card-link">Single-responsiblity Principle</a><br>
                                <a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#open-closed-principle"
                                   class="card-link">Open-closed Principle</a><br>
                                <a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#liskov-substitution-principle"
                                   class="card-link">Liskov Substitution Principle</a><br>
                                <a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#interface-segregation-principle"
                                   class="card-link">Interface Segregation Principle</a><br>
                                <a href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#dependency-inversion-principle"
                                   class="card-link">Dependency Inversion Principle</a>
                            </h6>
                        </div>
                        <h6 class="card-title">Reference links Design Pattern:<br>
                            <a href="https://refactoring.guru/design-patterns/python"
                               class="card-link">Design Pattern</a><br></h6>

                    </div>
                </div>
            </div>
        </div>
        <div class="row mb-1">
            <div class="col-9">
                <div class="card">
                    <div class="card-body"><h5>O - Open-closed Principle</h5>
                        <p class="h6"> "Objects or entities should be open for extension but closed for modification."
                            In
                            the below example on Calculator we can see that each class carries only one
                            responsibility example Addition class des only Addition</p>
                        <div class="card">
                            <div class="card-body bg-dark text-white">
                                <h6>
                                    class Calculations:<br>
                                    def __init__(self, list_passed_by_user):<br>
                                    self.list_1 = list_passed_by_user<br>
                                    <br>
                                    @abstractmethod<br>
                                    def get_output(self):<br>
                                    """This method is defined obeys the O - Open-closed Principle of SOLID as the method
                                    getout does the same
                                    function on all the class of getting output but the output differs on the operation,
                                    this method is
                                    therefore overriden by all the functions"""<br>
                                    pass<br>
                                    <br>
                                    class Addition(Calculations):<br>
                                    """The get_output method in calculator class calls the addition method in operations
                                    class where the actual addition is performed, here the user cannot directlly access
                                    the basic
                                    implementation of the function rather it has to call the get_output method to do the
                                    same
                                    Here Abstraction is also achieved as the by encapsulation of data"""<br>
                                    <br>
                                    def get_output(self):<br>
                                    result = 0<br>
                                    for i in self.list_1:<br>
                                    result = Operation.add(i, result)<br>
                                    return result<br>
                                    <br>
                                </h6>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row mb-1">
            <div class="col-9">
                <div class="card">
                    <div class="card-body"><h5>L - Liskov Substitution Principle</h5>
                        <p class="h6"> "Let q(x) be a property provable about objects of x of type T. Then q(y) should
                            be
                            provable for objects y of type S where S is a subtype of T." In
                            the below example on Calculator we can see that each class carries only one
                            responsibility example Addition class des only Addition<br>
                        </p>
                        <div class="card">
                            <div class="card-body bg-dark text-white">
                                <h6>
                                    class Calculations:<br>
                                    """This is the base class<br>
                                    The L - Liskov Substitution Principle states that the derived class should be used
                                    in
                                    substitution of base
                                    class, here we can use all the methods of the base class without changing the basic
                                    implementation in derived
                                    class without any unexpected behavior change to the base class."""<br>
                                    <br>def __init__(self, list_passed_by_user):<br>
                                    self.list_1 = list_passed_by_user<br>
                                    <br>
                                    @abstractmethod<br>
                                    def get_output(self):<br>
                                    on the operation, this method is therefore overriden by all the functions<br>
                                    pass<br>
                                    <br>
                                    class Addition(Calculations):<br>
                                    def get_output(self):<br>
                                    result = 0<br>
                                    for i in self.list_1:<br>
                                    result = Operation.add(i, result)<br>
                                    return result<br>
                                    <br><br>
                                </h6>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row mb-1">
            <div class="col-9">
                <div class="card">
                    <div class="card-body"><h5>I - Interface Segregation Principle</h5>
                        <p class="h6"> "A client should never be forced to implement an interface that it doesn’t use,
                            or
                            clients shouldn’t be forced to depend on methods they do not use." This states that many
                            client-specific interfaces are better than one general-purpose interface. In other words,
                            classes should not be forced to implement interfaces they do not use.</p>
                        <div class="card">
                            <div class="card-body bg-dark text-white">
                                <h6>
                                    class Calculations:<br>
                                    def __init__(self, list_passed_by_user):<br>
                                    self.list_1 = list_passed_by_user<br>
                                    """if we create another method say get_errors_displayed. This method will not be
                                    mandatory for all
                                    the derived class to override rather can be only be used by specific methods like
                                    division where error may occur"""<br>
                                    @abstractmethod<br>
                                    def get_output(self):<br>
                                    pass<br>
                                    <br>
                                    class Addition(Calculations):<br>
                                    def get_output(self):<br>
                                    result = 0<br>
                                    for i in self.list_1:<br>
                                    result = Operation.add(i, result)<br>
                                    return result<br>
                                </h6>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row mb-1">
            <div class="col-9">
                <div class="card">
                    <div class="card-body"><h5>D - Dependency Inversion Principle</h5>
                        <p class="h6"> "Entities must depend on abstractions, not on concretions. It states that the
                            high-level module must not depend on the low-level module, but they should depend on
                            abstractions.The Dependency Inversion principle states that our classes should depend
                            upon interfaces or abstract classes instead of concrete classes and functions."</p>
                        <div class="card">
                            <div class="card-body bg-dark text-white">
                                <h6>
                                    class Calculations:<br>
                                    def __init__(self, list_passed_by_user):<br>
                                    self.list_1 = list_passed_by_user<br>
                                    <br>
                                    @abstractmethod<br>
                                    def get_output(self):<br>
                                    """The Dependency Inversion principle states that our classes should depend upon<br>
                                    interfaces or
                                    abstract classes instead of concrete classes and functions. Here there is just one
                                    dependency that is also
                                    set on abstract class that is get_output as each calculation will have a output
                                    """<br>
                                    pass<br>
                                    <br>
                                    class Addition(Calculations):<br>
                                    def get_output(self):<br>
                                    result = 0<br>
                                    for i in self.list_1:<br>
                                    result = Operation.add(i, result)<br>
                                    return result
                                </h6>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="row">
        <img src="{{ url_for('static', filename='images/design-patterns.png') }}" class="d-block w-100"
             alt="{{ url_for('static', filename='images/design-patterns.png') }}">
    </div>

    <div class="row">
        <div class="row mb-1">
            <div class="col-9">
                <div class="card">
                    <div class="card-header h5">Design Pattern</div>
                    <h5>Design Pattern provide the general repeatable solution to a commonly occurring
                        in software design.</h5>
                    <br>
                    <div class="card"><h5>Creational Design pattern</h5>
                        <div class="card-body"><h5>Singleton</h5>
                            <p class="h6"> This pattern restricts the instantiation of a class to one object.
                                It is a type of creational pattern and involves only one class to
                                create methods and specified objects.
                                It provides a global point of access to the instance created.<br>
                            </p>
                            <div class="card">
                                <div class="card-body bg-dark text-white">
                                    <h6> def __new__(cls):<br>
                                        """ This is a singleton method.<br>
                                        Singleton creates an instance only if there is no instance created so far;<br>
                                        otherwise, it will return the instance that is already created."""<br>
                                        if not hasattr(cls, 'instance'):<br>
                                        cls.instance = super(History, cls).__new__(cls)<br>
                                        return cls.instance</h6><br>
                                </div>
                            </div>
                        </div>
                        <div class="card-body"><h5>Factory Method</h5>
                            <p class="h6"> Factory Method is a creational design pattern that provides an interface
                                for creating objects in a superclass, but allows subclasses to alter the type of objects
                                that will be created.<br>
                            </p></div>
                        <div class="card-body"><h5>Abstract Factory</h5>
                            <p class="h6"> Abstract Factory is a creational design pattern that lets you produce
                                families of related objects without specifying their concrete classes.<br>
                            </p></div>
                        <div class="card-body"><h5>Builder</h5>
                            <p class="h6"> Builder is a creational design pattern that lets you construct complex
                                objects step by step. The pattern allows you to produce different types and
                                representations of an object using the same construction code.<br>
                            </p></div>
                        <div class="card-body"><h5>Prototype</h5>
                            <p class="h6"> Prototype is a creational design pattern that lets you copy existing objects
                                without making your code dependent on their classes.<br>
                            </p></div>

                    </div>
                    <div class="card"><h5>Structural Design pattern</h5>
                        <div class="card-body"><h5>Facade</h5>
                            <p class="h6"> Facade design pattern provides a unified
                                interface to a set of interfaces in a subsystem. It defines a higher-level interface
                                that any subsystem can use..<br>
                            </p>
                            <div class="card">
                                <div class="card-body bg-dark text-white">
                                    <h6>"""we have our wraper class Caclulator which performs all the calculator
                                        operations
                                        which calls different function from different classes this is a example of
                                        Facade pattern"""<br>
                                    </h6>
                                </div>
                            </div>
                        </div>
                        <div class="card-body"><h5>Adapter</h5>
                            <p class="h6"> Adapter is a structural design pattern that allows objects with incompatible
                                interfaces to collaborate.<br>
                            </p></div>
                        <div class="card-body"><h5>Bridge</h5>
                            <p class="h6"> Bridge is a structural design pattern that lets you split a large class or a
                                set of closely related classes into two separate hierarchies—abstraction and
                                implementation—which can be developed independently of each other.<br>
                            </p></div>
                        <div class="card-body"><h5>Composite</h5>
                            <p class="h6"> Composite is a structural design pattern that lets you compose objects into
                                tree structures and then work with these structures as if they were individual objects.
                                <br>
                            </p></div>
                        <div class="card-body"><h5>Decorator</h5>
                            <p class="h6"> Decorator is a structural design pattern that lets you attach new behaviors
                                to objects by placing these objects inside special wrapper objects that contain the
                                behaviors.<br>
                            </p></div>
                        <div class="card-body"><h5>Flyweight</h5>
                            <p class="h6">Flyweight is a structural design pattern that lets you fit more objects into
                                the available amount of RAM by sharing common parts of state between multiple objects
                                instead of keeping all of the data in each object.<br>
                            </p></div>
                        <div class="card-body"><h5>Proxy</h5>
                            <p class="h6">Proxy is a structural design pattern that lets you provide a substitute or
                                placeholder for another object. A proxy controls access to the original object, allowing
                                you to perform something either before or after the request gets through to the original
                                object.<br>
                            </p></div>
                    </div>

                    <div class="card-body"><h5>Behavioral Design Patterns</h5>
                        <div class="card-body"><h5>Command</h5>
                            <p class="h6"> Command is a behavioral design pattern that turns a request into a
                                stand-alone
                                object that contains all information about the request. This transformation lets you
                                pass
                                requests as a method arguments, delay or queue a request’s execution, and support
                                undoable
                                operations.<br>
                            </p>
                            <div class="card">
                                <div class="card-body bg-dark text-white">
                                    <h6>"""In our calculator program we used this pattern, we call the get_output
                                        method of Addition,Substraction, Multiplication from the Calculaotr which is
                                        the main wraper class. The get_output method then call the actual addition
                                        method where 2 numbers are added"""
                                        class Calculator:<br>
                                        <br> """ This is the default result property"""
                                        <br> @staticmethod
                                        <br> def add(values):
                                        <br> """Addition of list"""
                                        <br> additions = Addition(values)
                                        <br> #a.validate_input()
                                        <br> hist = History()
                                        <br> hist.add_history(values, "Addition of", additions.get_output())
                                        <br> return additions.get_output()
                                        <br>
                                        <br> """The below is also a wraper class which calls the main addition method
                                        which
                                        adds 2 numbers"""
                                        <br> class Addition(Calculations):
                                        <br> """The get_output method in calculator class calls the addition method in
                                        operations
                                        <br> class where the actual addition is performed, here the user cannot
                                        directlly
                                        access the
                                        <br> basic
                                        <br> implementation of the function rather it has to call the get_output method
                                        to
                                        do the
                                        <br> same
                                        <br> Here Abstraction is also achieved as the by encapsulation of data"""
                                        <br>
                                        <br> def get_output(self):
                                        <br> result = 0
                                        <br> for i in self.list_1:
                                        <br> result = Operation.add(i, result)
                                        <br> return result
                                        <br>
                                        class Operation:<br>
                                        """Addition function<br>
                                        The below method is defined static as we are not changing the state of
                                        class"""<br>
                                        <br>
                                        @classmethod<br>
                                        def add(cls, value1, value2):<br>
                                        """Add numbers"""<br>
                                        result = value1+value2<br>
                                        return result
                                    </h6>
                                </div>
                            </div>
                        </div>
                        <div class="card-body"><h5>Chain of Responsibility</h5>
                            <p class="h6">Chain of Responsibility is a behavioral design pattern that lets you pass
                                requests along a chain of handlers. Upon receiving a request, each handler decides
                                either to process the request or to pass it to the next handler in the chain.

                                <br>
                            </p></div>
                        <div class="card-body"><h5>Proxy</h5>
                            <p class="h6">Proxy is a structural design pattern that lets you provide a substitute or
                                placeholder for another object. A proxy controls access to the original object, allowing
                                you to perform something either before or after the request gets through to the original
                                object.<br>
                            </p></div>
                        <div class="card-body"><h5>Iterator</h5>
                            <p class="h6">Iterator is a behavioral design pattern that lets you traverse elements of a
                                collection without exposing its underlying representation (list, stack, tree, etc.).
                                <br>
                            </p></div>
                        <div class="card-body"><h5>Mediator</h5>
                            <p class="h6">Mediator is a behavioral design pattern that lets you reduce chaotic
                                dependencies between objects. The pattern restricts direct communications between the
                                objects and forces them to collaborate only via a mediator object.

                                <br>
                            </p></div>
                        <div class="card-body"><h5>Memento</h5>
                            <p class="h6">Memento is a behavioral design pattern that lets you save and restore the
                                previous state of an object without revealing the details of its implementation.


                                <br>
                            </p></div>
                        <div class="card-body"><h5>Observer</h5>
                            <p class="h6">Observer is a behavioral design pattern that lets you define a subscription
                                mechanism to notify multiple objects about any events that happen to the object they’re
                                observing.
                                <br>
                            </p></div>
                        <div class="card-body"><h5>State</h5>
                            <p class="h6">State is a behavioral design pattern that lets an object alter its behavior
                                when its internal state changes. It appears as if the object changed its class.
                                <br>
                            </p></div>

                        <div class="card-body"><h5>Strategy</h5>
                            <p class="h6">Strategy is a behavioral design pattern that lets you define a family of
                                algorithms, put each of them into a separate class, and make their objects interchangeable.
                                <br>
                            </p></div>
                        <div class="card-body"><h5>Template Method</h5>
                            <p class="h6">Template Method is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.
                                <br>
                            </p></div>

                        <div class="card-body"><h5>Visitor</h5>
                            <p class="h6">Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate.
                                <br>
                            </p></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


</body>
</html>
{% endblock %}